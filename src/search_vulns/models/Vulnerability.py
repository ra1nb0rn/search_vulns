from __future__ import annotations

import datetime
from enum import Enum
from typing import Annotated, Dict, List, Set

from pydantic import BaseModel, Field, field_serializer

from .Severity import Severity, SeverityCVSS, SeverityEPSS, SeverityType


class DataSource(str, Enum):
    NVD = "nvd"
    NVDPP = "nvd++"
    GHSA = "ghsa"
    OSVDEV = "osv.dev"
    DEBIAN = "debian"
    UBUNTU = "ubuntu"
    REDHAT = "redhat"
    PRODUCT_SPECIFIC = "product_specific"
    OTHER = "other"


class MatchReason(str, Enum):
    PRODUCT_MATCH = "product_match"
    VERSION_IN_RANGE = "version_in_range"
    GENERAL_PRODUCT_OK = "general_product_ok"
    DESCRIPTION_MATCH = "description_match"
    GENERAL_PRODUCT_UNCERTAIN = "general_product_uncertain"
    SINGLE_HIGHER_VERSION = "single_higher_version"
    VULN_ID = "vuln_id"
    N_A = "n_a"

    @property
    def _priority(self) -> int:
        return _MATCH_REASON_PRIORITY[self]

    def __lt__(self, other):
        if isinstance(other, MatchReason):
            return self._priority < other._priority
        return NotImplemented


_MATCH_REASON_PRIORITY: dict[MatchReason, int] = {
    MatchReason.PRODUCT_MATCH: 8,
    MatchReason.VERSION_IN_RANGE: 7,
    MatchReason.GENERAL_PRODUCT_OK: 6,
    MatchReason.DESCRIPTION_MATCH: 5,
    MatchReason.GENERAL_PRODUCT_UNCERTAIN: 4,
    MatchReason.SINGLE_HIGHER_VERSION: 3,
    MatchReason.VULN_ID: 2,
    MatchReason.N_A: 1,
}


class Match(BaseModel):
    match_reason: MatchReason = Field(description="Reason for the match")
    confidence: float = Field(gt=0, le=1, description="Confidence for the match")

    model_config = {
        "title": "Vulnerability Match Model",
        "description": "Represents the match of a vulnerability to an affected software with a reason and confidence level",
    }


class Vulnerability(BaseModel):
    id: str = Field(min_length=1, description="Unique identifier for this vulnerability")
    match_reason: MatchReason = Field(
        description="Reason for why this vulnerability was matched"
    )
    tracked_by: Dict[
        DataSource
        | Annotated[
            str, Field(min_length=1, description="Textual identifier for the data source")
        ],
        Annotated[
            str,
            Field(
                min_length=1,
                description="Reference where the data source tracks this vulnerability",
            ),
        ],
    ] = Field(
        min_length=1,
        description="Stores which data sources keep track of this vulnerability and where",
    )
    matched_by: Dict[
        DataSource
        | Annotated[
            str, Field(min_length=1, description="Textual identifier for the data source")
        ],
        Match,
    ] = Field(
        min_length=1,
        description="Stores by which data sources the vulnerability was matched by",
    )
    reported_patched_by: Set[
        DataSource
        | Annotated[
            str, Field(min_length=1, description="Textual identifier for the data source")
        ]
    ] = Field(
        default_factory=set,
        min_length=1,
        description="Stores by which data sources the matched to product is considered patched against the vulnerability",
    )
    description: str = Field(default="", description="Description of the vulnerability")
    published: datetime.datetime = Field(
        default=None, description="Publish date of the vulnerability"
    )
    modified: datetime.datetime = Field(
        default=None, description="Modified date of the vulnerability"
    )
    severity: Dict[SeverityType, SeverityCVSS | SeverityEPSS] = Field(
        default_factory=dict,
        description="Stores different severity types for the vulnerability",
    )
    cwe_ids: Set[str] = Field(
        default_factory=set,
        description="Stores CWE-IDs for the vulnerability",
    )
    exploits: Set[Annotated[str, Field(min_length=1, description="Exploit URL")]] = Field(
        default_factory=set, description="Stores exploits references"
    )
    cisa_kev: bool = Field(
        default=False, description="Stores if the vulnerability is a CISA KEV"
    )
    aliases: Dict[
        Annotated[str, Field(min_length=1, description="Alias / vulnerability ID")],
        Annotated[
            str,
            Field(
                min_length=1,
                description="Reference or URL",
            ),
        ],
    ] = Field(
        default_factory=dict,
        description="Stores different IDs (aliases) for the vulnerability, alongside references with more details about the vulnerability and its ID",
    )
    misc: Dict[str, object] = Field(
        default_factory=dict, description="Other optional information about the vulnerability"
    )

    model_config = {
        "title": "Vulnerability Model",
        "description": "Represents a security vulnerability with its ID and various attributes",
    }

    @classmethod
    def from_vuln_match(
        cls,
        id: str,
        match_reason: MatchReason,
        source: DataSource | str,
        match_reference: str,
        confidence: float = 1,
    ):
        vuln_track = {source: match_reference}
        matched_by = {source: Match(match_reason=match_reason, confidence=confidence)}
        return cls(
            id=id, match_reason=match_reason, tracked_by=vuln_track, matched_by=matched_by
        )

    @classmethod
    def from_vuln_match_with_vuln_reference(
        cls,
        id: str,
        match_reason: MatchReason,
        source: DataSource | str,
        match_reference: str,
        vuln_reference: str,
        confidence: float = 1,
    ):
        vuln = cls.from_vuln_match(id, match_reason, source, match_reference, confidence)
        vuln.add_alias(id, vuln_reference)
        return vuln

    @classmethod
    def from_vuln_match_complete(
        cls,
        id: str,
        match_reason: MatchReason,
        source: DataSource | str,
        match_reference: str,
        vuln_reference: str,
        description: str,
        published: datetime.datetime,
        modified: datetime.datetime,
        severity: Severity,
        cwe_ids: Set[str] | List[str],
        cisa_kev: bool,
        exploits: Set[str] | List[str],
        confidence: float = 1,
    ):
        vuln = cls.from_vuln_match_with_vuln_reference(
            id,
            match_reason,
            source,
            match_reference,
            vuln_reference,
            confidence,
        )
        vuln.description = description
        vuln.published = published
        vuln.modified = modified
        if severity:
            vuln.add_severity(severity)
        if cwe_ids:
            vuln.add_cwe_ids(cwe_ids)
        vuln.cisa_kev = cisa_kev
        if exploits:
            vuln.add_exploits(exploits)
        return vuln

    @field_serializer("published", "modified")
    def serialize_dates(self, value):
        if not value:
            return None
        return str(value)

    @field_serializer("cwe_ids", "exploits", "reported_patched_by")
    def serialize_sets(self, value):
        return list(value)

    # Getters and setters
    def get_id(self) -> str:
        return self.id

    def set_id(self, value: str):
        self.id = value

    def get_match_reason(self) -> MatchReason:
        return self.match_reason

    def set_match_reason(self, value: MatchReason):
        self.match_reason = value

    def get_tracked_by(self) -> Dict[DataSource | str, str]:
        return self.tracked_by

    def set_tracked_by(self, value: Dict[DataSource | str, str]):
        self.tracked_by = value

    def add_tracked_by(self, source: DataSource | str, ref: str):
        self.tracked_by[source] = ref

    def remove_tracked_by(self, source: DataSource | str):
        if source in self.tracked_by:
            del self.tracked_by[source]

    def get_matched_by(self) -> Dict[DataSource | str, Match]:
        return self.matched_by

    def set_matched_by(self, value: Dict[DataSource | str, Match]):
        self.matched_by = value

    def add_matched_by(self, source: DataSource | str, match: Match):
        self.matched_by[source] = match
        if match.match_reason > self.match_reason:
            self.match_reason = match.match_reason

    def remove_matched_by(self, source: DataSource | str):
        if source in self.matched_by:
            del self.matched_by[source]

    def get_reported_patched_by(self) -> Set[DataSource | str]:
        return self.reported_patched_by

    def set_reported_patched_by(self, value: Set[DataSource | str]):
        self.reported_patched_by = value

    def set_patched(self, source: DataSource | str):
        if source not in self.reported_patched_by:
            self.reported_patched_by.add(source)

    def is_patched(self) -> bool:
        return bool(self.reported_patched_by)

    def get_description(self) -> str:
        return self.description

    def set_description(self, value: str):
        self.description = value

    def get_published(self) -> datetime.datetime:
        return self.published

    def set_published(self, value: datetime.datetime):
        self.published = value

    def get_modified(self) -> datetime.datetime:
        return self.modified

    def set_modified(self, value: datetime.datetime):
        self.modified = value

    def get_severity(self) -> Dict[SeverityType, Severity]:
        return self.severity

    def set_severity(self, value: Dict[SeverityType, Severity]):
        self.severity = value

    def get_severity_by_type(self, severity_type: SeverityType) -> Severity:
        return self.severity[severity_type]

    def add_severity(self, severity: Severity):
        self.severity[severity.type] = severity

    def get_cwe_ids(self) -> Set[str]:
        return self.cwe_ids

    def set_cwe_ids(self, cwe_ids: Set[str] | List[str]):
        self.cwe_ids = set(cwe_ids)

    def add_cwe_ids(self, cwe_ids: Set[str] | List[str]):
        self.cwe_ids |= set(cwe_ids)

    def add_cwe_id(self, cwe_id: str):
        self.cwe_ids.add(cwe_id)

    def get_cisa_known_exploited(self) -> bool:
        return self.cisa_known_exploited

    def set_cisa_known_exploited(self, value: bool):
        self.cisa_known_exploited = value

    def get_aliases(self) -> Dict[str, str]:
        return self.aliases

    def set_aliases(self, value: Dict[str, str]):
        self.aliases = value

    def add_alias(self, alias_vuln_id: str, alias_reference: str):
        self.aliases[alias_vuln_id] = alias_reference

    def add_tracked_by_with_alias(self, source: DataSource | str, ref: str, alias_vuln_id: str):
        self.tracked_by[source] = ref
        self.add_alias(alias_vuln_id, ref)

    def get_exploits(self) -> Set[str]:
        return self.exploits

    def set_exploits(self, exploits: Set[str] | List[str]):
        self.exploits = exploits

    def add_exploits(self, exploits: Set[str] | List[str]):
        if (not isinstance(exploits, list)) and (not isinstance(exploits, set)):
            exploits = set([exploits])
        for exploit in exploits:
            if exploit.endswith("/"):
                if exploit[:-1] in self.exploits:
                    continue
                elif exploit.startswith("http:") and "https:" + exploit[5:] in self.exploits:
                    continue
                if exploit + ".git" not in self.exploits:
                    self.exploits.add(exploit)
            else:
                if exploit.startswith("http:") and "https:" + exploit[5:] in self.exploits:
                    continue
                if exploit + "/" in self.exploits:
                    self.exploits.remove(exploit + "/")
                if exploit + ".git" not in self.exploits:
                    self.exploits.add(exploit)

    def add_exploit(self, exploit: str):
        self.add_exploits([exploit])

    def get_cisa_kev(self) -> bool:
        return self.cisa_kev

    def set_cisa_kev(self, cisa_kev: bool):
        self.cisa_kev = cisa_kev

    def get_misc(self) -> Dict[str, str]:
        return self.misc

    def set_misc(self, misc: Dict[str, str]):
        self.misc = misc

    def add_to_misc(self, key: str, value: object):
        self.misc[key] = value

    def get_cvss_score(self) -> str:
        if SeverityType.CVSS in self.severity:
            return float(self.severity[SeverityType.CVSS].score)
        else:
            return -1

    def get_cvss_version(self) -> str:
        if SeverityType.CVSS in self.severity:
            return self.severity[SeverityType.CVSS].version
        else:
            return -1

    def get_cvss_vector(self) -> str:
        if SeverityType.CVSS in self.severity:
            return self.severity[SeverityType.CVSS].vector
        else:
            return "n/a"

    def get_epss_score(self) -> str:
        if SeverityType.EPSS in self.severity:
            return float(self.severity[SeverityType.EPSS].score)
        else:
            return "-1"

    def is_same_vulnerability_as(self, other: Vulnerability):
        if not isinstance(other, self.__class__):
            return False
        if self.id == other.id:
            return True
        if self.id in other.aliases:
            return True
        if other.id in self.aliases:
            return True
        return False

    def merge_with(self, other: Vulnerability):
        if not other:
            return
        if not isinstance(other, self.__class__):
            raise TypeError("Can only merge with object of type Vulnerability")

        # copy over simple values of other vuln if this one doesn't have it
        for key in ("description", "published", "modified"):
            if not getattr(self, key):
                setattr(self, key, getattr(other, key))

        # copy over new matched_by or the one of better match_reason
        for data_source, match_reason in other.matched_by.items():
            if data_source not in self.matched_by or other.match_reason > self.match_reason:
                self.matched_by[data_source] = match_reason

        # copy over new tracked_by or the one of better match_reason
        for data_source, reference in other.tracked_by.items():
            if data_source not in self.tracked_by or other.match_reason > self.match_reason:
                self.tracked_by[data_source] = reference

        # copy over new reported_patched_by
        for data_source in other.reported_patched_by:
            self.reported_patched_by.add(data_source)

        # copy over new severity or the one of better match_reason
        for type, severity in other.severity.items():
            if type not in self.severity or other.match_reason > self.match_reason:
                self.severity[type] = severity

        # merge CWE-IDs
        self.add_cwe_ids(other.cwe_ids)

        # merge CISA KEV
        if other.cisa_kev:
            self.cisa_kev = True

        # merge exploits
        self.add_exploits(other.exploits)

        # merge aliases (ID of a vuln will always have to be stored as alias already)
        # copy over new alias or the one of better match_reason
        for alias, reference in other.aliases.items():
            if alias not in self.aliases or other.match_reason > self.match_reason:
                self.aliases[alias] = reference

        # merge misc items up to one level, otherwise discard
        for key, value in other.misc.items():
            if key not in self.misc:
                self.misc[key] = value
            elif isinstance(self.misc[key], list) and isinstance(value, list):
                self.misc[key] = list(set(self.misc[key] + value))
            elif isinstance(self.misc[key], dict) and isinstance(value, dict):
                for key2, val2 in value.items():
                    if key2 not in self.misc[key]:
                        self.misc[key][key2] = val2

        # choose best match_reason of both
        if other.match_reason > self.match_reason:
            self.match_reason = other.match_reason
