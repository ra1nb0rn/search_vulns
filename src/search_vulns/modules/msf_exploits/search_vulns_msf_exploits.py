import os
import re
import shutil
import subprocess
from typing import List

from search_vulns.modules.utils import SQLITE_TIMEOUT, get_database_connection
from search_vulns.vulnerability import Vulnerability

SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
METASPLOIT_GITHUB_REPO = "https://github.com/rapid7/metasploit-framework/"
METASPLOIT_EXPLOIT_DIR = "modules/exploits"
METASPLOIT_REPO_OUTDIR = os.path.join(SCRIPT_DIR, "metasploit-framework")
REFERENCES_BLOCK_EXTRACT_RE = re.compile(
    r"['\"]References['\"]\s*=>\s*(\[(.*)\]\s*\](,\s*['\"])?)", re.DOTALL
)
EXTRACT_REFERENCE_IDS_RE = re.compile(r"\[\s*['\"]([A-Z]+)['\"]\s*,\s*['\"]([\w\-]+)['\"]\s*\]")
REQUIRES_BUILT_MODULES = ["exploit_db.search_vulns_edb", "nvd.search_vulns_nvd"]


def download_msf_exploits_repo():
    # download msf exploits from GitHub
    return_code = subprocess.call(
        "git clone -n --depth=1 --filter=tree:0 %s '%s' && "
        % (METASPLOIT_GITHUB_REPO, METASPLOIT_REPO_OUTDIR)
        + "cd %s && " % METASPLOIT_REPO_OUTDIR
        + "git sparse-checkout set --no-cone %s && " % METASPLOIT_EXPLOIT_DIR
        + "git checkout",
        shell=True,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )
    if return_code != 0:
        return False
    return True


def get_raw_msf_exploits_data():
    # iterate over every exploit file
    cve_id_references, edb_references = {}, {}

    for dirpath, _, filenames in os.walk(
        os.path.join(METASPLOIT_REPO_OUTDIR, METASPLOIT_EXPLOIT_DIR)
    ):
        for filename in filenames:
            if filename.endswith(".rb"):
                filepath = os.path.join(dirpath, filename)
                exploit_url = (
                    METASPLOIT_GITHUB_REPO
                    + "tree/master/"
                    + filepath[filepath.find(METASPLOIT_EXPLOIT_DIR) :]
                )
                with open(filepath) as f:
                    content = f.read()

                # extract reference information of exploit
                references_block = REFERENCES_BLOCK_EXTRACT_RE.findall(content)
                if references_block:
                    references = EXTRACT_REFERENCE_IDS_RE.findall(references_block[0][0])
                    for reference in references:
                        if reference[0].lower() == "edb":
                            if exploit_url not in edb_references:
                                edb_references[exploit_url] = []
                            edb_references[exploit_url].append(reference[1])
                        elif reference[0].lower() == "cve":
                            if exploit_url not in cve_id_references:
                                cve_id_references[exploit_url] = []
                            cve_id_references[exploit_url].append("CVE-" + reference[1])

    return cve_id_references, edb_references


def dedup_with_edb_exploit_refs(db_cursor, raw_cve_id_references, edb_references):
    # remove msf_exploit_url <-> cve_id reference if a cve_id <-> edb mapping exists
    cve_id_references = {}
    for exploit_url, cve_ids in raw_cve_id_references.items():
        for cve_id in cve_ids:
            edb_exploits = set()
            db_cursor.execute("SELECT edb_ids FROM cve_edb WHERE cve_id = ?", (cve_id,))
            result = db_cursor.fetchone()
            if result:
                edb_exploits |= set(result[0].split(","))  # only ever one row per CVE is stored

            db_cursor.execute(
                "SELECT exploit_ref FROM nvd_exploits_refs_view WHERE cve_id = ?", (cve_id,)
            )
            for edb_url in db_cursor.fetchall():
                edb_id = edb_url[edb_url[0].rfind("/") + 1 :]
                edb_exploits.add(edb_id)

            if any(
                msf_edb_id in edb_exploits for msf_edb_id in edb_references.get(exploit_url, [])
            ):
                continue

            if cve_id not in cve_id_references:
                cve_id_references[cve_id] = set()
            cve_id_references[cve_id].add(exploit_url)

    return cve_id_references


def full_update(productdb_config, vulndb_config, module_config, stop_update):
    # download and process metasploit exploit data
    if os.path.isdir(METASPLOIT_REPO_OUTDIR):
        shutil.rmtree(METASPLOIT_REPO_OUTDIR)

    download_msf_exploits_repo()
    raw_cve_id_references, edb_references = get_raw_msf_exploits_data()

    # get DB connection
    db_conn = get_database_connection(vulndb_config, sqlite_timeout=SQLITE_TIMEOUT)
    db_cursor = db_conn.cursor()

    cve_id_references = dedup_with_edb_exploit_refs(
        db_cursor, raw_cve_id_references, edb_references
    )

    if os.path.isdir(METASPLOIT_REPO_OUTDIR):
        shutil.rmtree(METASPLOIT_REPO_OUTDIR)

    # create new tables
    if vulndb_config["TYPE"] == "sqlite":
        create_table_stmt = "DROP TABLE IF EXISTS cve_msf_exploit_map; CREATE TABLE cve_msf_exploit_map (cve_id VARCHAR(25), msf_exploit_url VARCHAR(255), PRIMARY KEY (cve_id, msf_exploit_url));"
    elif vulndb_config["TYPE"] == "mariadb":
        create_table_stmt = "CREATE OR REPLACE TABLE cve_msf_exploit_map (cve_id VARCHAR(25), msf_exploit_url VARCHAR(255) CHARACTER SET ascii, PRIMARY KEY (cve_id, msf_exploit_url));"
    for stmt in create_table_stmt.split(";"):
        if stmt:
            db_cursor.execute(stmt + ";")

    # insert metasploit exploit data into DB
    for cve_id, exploit_refs in cve_id_references.items():
        for exploit_ref in exploit_refs:
            db_cursor.execute(
                "INSERT INTO cve_msf_exploit_map VALUES (?, ?);", (cve_id, exploit_ref)
            )

    db_conn.commit()
    db_cursor.close()
    db_conn.close()

    return True, []


def add_extra_vuln_info(vulns: List[Vulnerability], vuln_db_cursor, config, extra_params):
    for vuln_id, vuln in vulns.items():
        vuln_cve_ids = set()
        if vuln_id.startswith("CVE-"):
            vuln_cve_ids.add(vuln_id)
        for alias in vuln.aliases:
            if alias.startswith("CVE-"):
                vuln_cve_ids.add(alias)

        exploits = set()
        for cve_id in vuln_cve_ids:
            vuln_db_cursor.execute(
                "SELECT msf_exploit_url FROM cve_msf_exploit_map WHERE cve_id = ?", (cve_id,)
            )
            msf_exploit_urls = vuln_db_cursor.fetchall()
            for msf_exploit_url in msf_exploit_urls:
                exploits.add(msf_exploit_url[0])

        vuln.add_exploits(exploits)
